{"ast":null,"code":"import createTime from './createTime';\nfunction aggregateTests(testsResponse, aggTime, toggleExclusion, absoluteXAxis, absoluteYAxis, setAbsoluteXAxis, setAbsoluteYAxis) {\n  aggTime = parseInt(aggTime);\n  const formatedTests = [];\n  let testsTracker = {\n    total: 0,\n    cummulative: 0\n  };\n  let trackedMilliseconds;\n  const startExlusion = toggleExclusion ? Math.floor(testsResponse.length * 0.02) : 0;\n  const excludedTests = testsResponse.slice(startExlusion);\n  if (!absoluteXAxis) {\n    setAbsoluteXAxis(excludedTests[excludedTests.length - 1][0]);\n  }\n  let maxY = 0;\n  excludedTests.forEach((row, i) => {\n    maxY = Math.max(maxY, row[1]);\n    let millisecStamp = Date.parse(row[0]);\n    let timeToFormat = new Date(trackedMilliseconds);\n    if (!trackedMilliseconds) {\n      trackedMilliseconds = millisecStamp;\n      testsTracker.total += 1;\n      testsTracker.cummulative += row[1];\n    } else if (millisecStamp >= trackedMilliseconds + 1000 * aggTime) {\n      formatedTests.push({\n        time: createTime(timeToFormat),\n        runtime: testsTracker.cummulative / testsTracker.total\n      });\n      trackedMilliseconds = millisecStamp;\n      testsTracker = {\n        total: 0,\n        cummulative: 0\n      };\n      testsTracker.total += 1;\n      testsTracker.cummulative += Number(row[1]);\n    } else if (i + 1 === testsResponse.length) {\n      formatedTests.push({\n        time: createTime(timeToFormat),\n        runtime: testsTracker.cummulative / testsTracker.total\n      });\n      testsTracker = {\n        total: 0,\n        cummulative: 0\n      };\n    }\n  });\n  if (!absoluteYAxis) {\n    setAbsoluteYAxis(maxY);\n  }\n  return formatedTests;\n}\nexport default aggregateTests;","map":{"version":3,"names":["createTime","aggregateTests","testsResponse","aggTime","toggleExclusion","absoluteXAxis","absoluteYAxis","setAbsoluteXAxis","setAbsoluteYAxis","parseInt","formatedTests","testsTracker","total","cummulative","trackedMilliseconds","startExlusion","Math","floor","length","excludedTests","slice","maxY","forEach","row","i","max","millisecStamp","Date","parse","timeToFormat","push","time","runtime","Number"],"sources":["/home/jakedevar/help_constellation/constellation-local/constellation-visualizer/src/utils/aggregateTests.js"],"sourcesContent":["import createTime from './createTime';\nfunction aggregateTests(testsResponse, aggTime, toggleExclusion, absoluteXAxis, absoluteYAxis, setAbsoluteXAxis, setAbsoluteYAxis) {\n  aggTime = parseInt(aggTime);\n  const formatedTests = [];\n  let testsTracker = {\n    total: 0,\n    cummulative: 0\n  };\n  let trackedMilliseconds;\n  const startExlusion = toggleExclusion ? Math.floor(testsResponse.length * 0.02): 0;\n  const excludedTests = testsResponse.slice(startExlusion);\n  if (!absoluteXAxis) {\n    setAbsoluteXAxis(excludedTests[excludedTests.length - 1][0]);\n  }\n  let maxY = 0;\n  excludedTests.forEach((row, i) => {\n    maxY = Math.max(maxY, row[1]);\n    let millisecStamp = Date.parse(row[0])\n    let timeToFormat = new Date(trackedMilliseconds);\n    if (!trackedMilliseconds) {\n      trackedMilliseconds = millisecStamp;\n      testsTracker.total += 1;\n      testsTracker.cummulative += row[1];\n    } else if (millisecStamp >= trackedMilliseconds + (1000 * aggTime)) {\n      formatedTests.push({\n        time: createTime(timeToFormat),\n        runtime: testsTracker.cummulative / testsTracker.total\n      });\n      trackedMilliseconds = millisecStamp;\n      testsTracker = {\n        total: 0,\n        cummulative: 0\n      };\n      testsTracker.total += 1;\n      testsTracker.cummulative += Number(row[1]);\n    } else if (i+1 === testsResponse.length) {\n      formatedTests.push({\n        time: createTime(timeToFormat),\n        runtime: testsTracker.cummulative / testsTracker.total\n      });\n      testsTracker = {\n        total: 0,\n        cummulative: 0\n      };\n    } \n  })\n  if (!absoluteYAxis) {\n    setAbsoluteYAxis(maxY);\n  }\n  return formatedTests;\n}\n\nexport default aggregateTests;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,cAAc;AACrC,SAASC,cAAc,CAACC,aAAa,EAAEC,OAAO,EAAEC,eAAe,EAAEC,aAAa,EAAEC,aAAa,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAE;EACjIL,OAAO,GAAGM,QAAQ,CAACN,OAAO,CAAC;EAC3B,MAAMO,aAAa,GAAG,EAAE;EACxB,IAAIC,YAAY,GAAG;IACjBC,KAAK,EAAE,CAAC;IACRC,WAAW,EAAE;EACf,CAAC;EACD,IAAIC,mBAAmB;EACvB,MAAMC,aAAa,GAAGX,eAAe,GAAGY,IAAI,CAACC,KAAK,CAACf,aAAa,CAACgB,MAAM,GAAG,IAAI,CAAC,GAAE,CAAC;EAClF,MAAMC,aAAa,GAAGjB,aAAa,CAACkB,KAAK,CAACL,aAAa,CAAC;EACxD,IAAI,CAACV,aAAa,EAAE;IAClBE,gBAAgB,CAACY,aAAa,CAACA,aAAa,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC9D;EACA,IAAIG,IAAI,GAAG,CAAC;EACZF,aAAa,CAACG,OAAO,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAK;IAChCH,IAAI,GAAGL,IAAI,CAACS,GAAG,CAACJ,IAAI,EAAEE,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7B,IAAIG,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC,CAAC;IACtC,IAAIM,YAAY,GAAG,IAAIF,IAAI,CAACb,mBAAmB,CAAC;IAChD,IAAI,CAACA,mBAAmB,EAAE;MACxBA,mBAAmB,GAAGY,aAAa;MACnCf,YAAY,CAACC,KAAK,IAAI,CAAC;MACvBD,YAAY,CAACE,WAAW,IAAIU,GAAG,CAAC,CAAC,CAAC;IACpC,CAAC,MAAM,IAAIG,aAAa,IAAIZ,mBAAmB,GAAI,IAAI,GAAGX,OAAQ,EAAE;MAClEO,aAAa,CAACoB,IAAI,CAAC;QACjBC,IAAI,EAAE/B,UAAU,CAAC6B,YAAY,CAAC;QAC9BG,OAAO,EAAErB,YAAY,CAACE,WAAW,GAAGF,YAAY,CAACC;MACnD,CAAC,CAAC;MACFE,mBAAmB,GAAGY,aAAa;MACnCf,YAAY,GAAG;QACbC,KAAK,EAAE,CAAC;QACRC,WAAW,EAAE;MACf,CAAC;MACDF,YAAY,CAACC,KAAK,IAAI,CAAC;MACvBD,YAAY,CAACE,WAAW,IAAIoB,MAAM,CAACV,GAAG,CAAC,CAAC,CAAC,CAAC;IAC5C,CAAC,MAAM,IAAIC,CAAC,GAAC,CAAC,KAAKtB,aAAa,CAACgB,MAAM,EAAE;MACvCR,aAAa,CAACoB,IAAI,CAAC;QACjBC,IAAI,EAAE/B,UAAU,CAAC6B,YAAY,CAAC;QAC9BG,OAAO,EAAErB,YAAY,CAACE,WAAW,GAAGF,YAAY,CAACC;MACnD,CAAC,CAAC;MACFD,YAAY,GAAG;QACbC,KAAK,EAAE,CAAC;QACRC,WAAW,EAAE;MACf,CAAC;IACH;EACF,CAAC,CAAC;EACF,IAAI,CAACP,aAAa,EAAE;IAClBE,gBAAgB,CAACa,IAAI,CAAC;EACxB;EACA,OAAOX,aAAa;AACtB;AAEA,eAAeT,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}
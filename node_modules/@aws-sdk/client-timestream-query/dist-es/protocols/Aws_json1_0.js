import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, limitedParseDouble as __limitedParseDouble, parseEpochTimestamp as __parseEpochTimestamp, throwDefaultError, } from "@aws-sdk/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { AccessDeniedException, ConflictException, InternalServerException, InvalidEndpointException, QueryExecutionException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, ValidationException, } from "../models/models_0";
import { TimestreamQueryServiceException as __BaseException } from "../models/TimestreamQueryServiceException";
export const serializeAws_json1_0CancelQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.CancelQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0CancelQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0CreateScheduledQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.CreateScheduledQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0CreateScheduledQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0DeleteScheduledQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.DeleteScheduledQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0DeleteScheduledQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0DescribeEndpointsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.DescribeEndpoints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0DescribeEndpointsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0DescribeScheduledQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.DescribeScheduledQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0DescribeScheduledQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0ExecuteScheduledQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.ExecuteScheduledQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0ExecuteScheduledQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0ListScheduledQueriesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.ListScheduledQueries",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0ListScheduledQueriesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0ListTagsForResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0PrepareQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.PrepareQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0PrepareQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0QueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.Query",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0QueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_0UpdateScheduledQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.0",
        "x-amz-target": "Timestream_20181101.UpdateScheduledQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_0UpdateScheduledQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const deserializeAws_json1_0CancelQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0CancelQueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0CancelQueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0CancelQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0CreateScheduledQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0CreateScheduledQueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0CreateScheduledQueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0CreateScheduledQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.timestreamquery#ConflictException":
            throw await deserializeAws_json1_0ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.timestreamquery#ServiceQuotaExceededException":
            throw await deserializeAws_json1_0ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0DeleteScheduledQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0DeleteScheduledQueryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0DeleteScheduledQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0DescribeEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0DescribeEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0DescribeEndpointsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0DescribeEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0DescribeScheduledQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0DescribeScheduledQueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0DescribeScheduledQueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0DescribeScheduledQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0ExecuteScheduledQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0ExecuteScheduledQueryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0ExecuteScheduledQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0ListScheduledQueriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0ListScheduledQueriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0ListScheduledQueriesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0ListScheduledQueriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0ListTagsForResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0PrepareQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0PrepareQueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0PrepareQueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0PrepareQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0QueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0QueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0QueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0QueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.timestreamquery#ConflictException":
            throw await deserializeAws_json1_0ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "QueryExecutionException":
        case "com.amazonaws.timestreamquery#QueryExecutionException":
            throw await deserializeAws_json1_0QueryExecutionExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0TagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.timestreamquery#ServiceQuotaExceededException":
            throw await deserializeAws_json1_0ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_0UntagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_0UpdateScheduledQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_0UpdateScheduledQueryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_0UpdateScheduledQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.timestreamquery#AccessDeniedException":
            throw await deserializeAws_json1_0AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.timestreamquery#InternalServerException":
            throw await deserializeAws_json1_0InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidEndpointException":
        case "com.amazonaws.timestreamquery#InvalidEndpointException":
            throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.timestreamquery#ResourceNotFoundException":
            throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.timestreamquery#ThrottlingException":
            throw await deserializeAws_json1_0ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.timestreamquery#ValidationException":
            throw await deserializeAws_json1_0ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
const deserializeAws_json1_0AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0AccessDeniedException(body, context);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0ConflictExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0ConflictException(body, context);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0InternalServerExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0InternalServerException(body, context);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0InvalidEndpointExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0InvalidEndpointException(body, context);
    const exception = new InvalidEndpointException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0QueryExecutionExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0QueryExecutionException(body, context);
    const exception = new QueryExecutionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0ResourceNotFoundException(body, context);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0ServiceQuotaExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0ServiceQuotaExceededException(body, context);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0ThrottlingExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0ThrottlingException(body, context);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_0ValidationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_0ValidationException(body, context);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const serializeAws_json1_0CancelQueryRequest = (input, context) => {
    return {
        ...(input.QueryId != null && { QueryId: input.QueryId }),
    };
};
const serializeAws_json1_0CreateScheduledQueryRequest = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.ErrorReportConfiguration != null && {
            ErrorReportConfiguration: serializeAws_json1_0ErrorReportConfiguration(input.ErrorReportConfiguration, context),
        }),
        ...(input.KmsKeyId != null && { KmsKeyId: input.KmsKeyId }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NotificationConfiguration != null && {
            NotificationConfiguration: serializeAws_json1_0NotificationConfiguration(input.NotificationConfiguration, context),
        }),
        ...(input.QueryString != null && { QueryString: input.QueryString }),
        ...(input.ScheduleConfiguration != null && {
            ScheduleConfiguration: serializeAws_json1_0ScheduleConfiguration(input.ScheduleConfiguration, context),
        }),
        ...(input.ScheduledQueryExecutionRoleArn != null && {
            ScheduledQueryExecutionRoleArn: input.ScheduledQueryExecutionRoleArn,
        }),
        ...(input.Tags != null && { Tags: serializeAws_json1_0TagList(input.Tags, context) }),
        ...(input.TargetConfiguration != null && {
            TargetConfiguration: serializeAws_json1_0TargetConfiguration(input.TargetConfiguration, context),
        }),
    };
};
const serializeAws_json1_0DeleteScheduledQueryRequest = (input, context) => {
    return {
        ...(input.ScheduledQueryArn != null && { ScheduledQueryArn: input.ScheduledQueryArn }),
    };
};
const serializeAws_json1_0DescribeEndpointsRequest = (input, context) => {
    return {};
};
const serializeAws_json1_0DescribeScheduledQueryRequest = (input, context) => {
    return {
        ...(input.ScheduledQueryArn != null && { ScheduledQueryArn: input.ScheduledQueryArn }),
    };
};
const serializeAws_json1_0DimensionMapping = (input, context) => {
    return {
        ...(input.DimensionValueType != null && { DimensionValueType: input.DimensionValueType }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_0DimensionMappingList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_0DimensionMapping(entry, context);
    });
};
const serializeAws_json1_0ErrorReportConfiguration = (input, context) => {
    return {
        ...(input.S3Configuration != null && {
            S3Configuration: serializeAws_json1_0S3Configuration(input.S3Configuration, context),
        }),
    };
};
const serializeAws_json1_0ExecuteScheduledQueryRequest = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.InvocationTime != null && { InvocationTime: Math.round(input.InvocationTime.getTime() / 1000) }),
        ...(input.ScheduledQueryArn != null && { ScheduledQueryArn: input.ScheduledQueryArn }),
    };
};
const serializeAws_json1_0ListScheduledQueriesRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_0ListTagsForResourceRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceARN != null && { ResourceARN: input.ResourceARN }),
    };
};
const serializeAws_json1_0MixedMeasureMapping = (input, context) => {
    return {
        ...(input.MeasureName != null && { MeasureName: input.MeasureName }),
        ...(input.MeasureValueType != null && { MeasureValueType: input.MeasureValueType }),
        ...(input.MultiMeasureAttributeMappings != null && {
            MultiMeasureAttributeMappings: serializeAws_json1_0MultiMeasureAttributeMappingList(input.MultiMeasureAttributeMappings, context),
        }),
        ...(input.SourceColumn != null && { SourceColumn: input.SourceColumn }),
        ...(input.TargetMeasureName != null && { TargetMeasureName: input.TargetMeasureName }),
    };
};
const serializeAws_json1_0MixedMeasureMappingList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_0MixedMeasureMapping(entry, context);
    });
};
const serializeAws_json1_0MultiMeasureAttributeMapping = (input, context) => {
    return {
        ...(input.MeasureValueType != null && { MeasureValueType: input.MeasureValueType }),
        ...(input.SourceColumn != null && { SourceColumn: input.SourceColumn }),
        ...(input.TargetMultiMeasureAttributeName != null && {
            TargetMultiMeasureAttributeName: input.TargetMultiMeasureAttributeName,
        }),
    };
};
const serializeAws_json1_0MultiMeasureAttributeMappingList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_0MultiMeasureAttributeMapping(entry, context);
    });
};
const serializeAws_json1_0MultiMeasureMappings = (input, context) => {
    return {
        ...(input.MultiMeasureAttributeMappings != null && {
            MultiMeasureAttributeMappings: serializeAws_json1_0MultiMeasureAttributeMappingList(input.MultiMeasureAttributeMappings, context),
        }),
        ...(input.TargetMultiMeasureName != null && { TargetMultiMeasureName: input.TargetMultiMeasureName }),
    };
};
const serializeAws_json1_0NotificationConfiguration = (input, context) => {
    return {
        ...(input.SnsConfiguration != null && {
            SnsConfiguration: serializeAws_json1_0SnsConfiguration(input.SnsConfiguration, context),
        }),
    };
};
const serializeAws_json1_0PrepareQueryRequest = (input, context) => {
    return {
        ...(input.QueryString != null && { QueryString: input.QueryString }),
        ...(input.ValidateOnly != null && { ValidateOnly: input.ValidateOnly }),
    };
};
const serializeAws_json1_0QueryRequest = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.MaxRows != null && { MaxRows: input.MaxRows }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.QueryString != null && { QueryString: input.QueryString }),
    };
};
const serializeAws_json1_0S3Configuration = (input, context) => {
    return {
        ...(input.BucketName != null && { BucketName: input.BucketName }),
        ...(input.EncryptionOption != null && { EncryptionOption: input.EncryptionOption }),
        ...(input.ObjectKeyPrefix != null && { ObjectKeyPrefix: input.ObjectKeyPrefix }),
    };
};
const serializeAws_json1_0ScheduleConfiguration = (input, context) => {
    return {
        ...(input.ScheduleExpression != null && { ScheduleExpression: input.ScheduleExpression }),
    };
};
const serializeAws_json1_0SnsConfiguration = (input, context) => {
    return {
        ...(input.TopicArn != null && { TopicArn: input.TopicArn }),
    };
};
const serializeAws_json1_0Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_0TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_0TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_0Tag(entry, context);
    });
};
const serializeAws_json1_0TagResourceRequest = (input, context) => {
    return {
        ...(input.ResourceARN != null && { ResourceARN: input.ResourceARN }),
        ...(input.Tags != null && { Tags: serializeAws_json1_0TagList(input.Tags, context) }),
    };
};
const serializeAws_json1_0TargetConfiguration = (input, context) => {
    return {
        ...(input.TimestreamConfiguration != null && {
            TimestreamConfiguration: serializeAws_json1_0TimestreamConfiguration(input.TimestreamConfiguration, context),
        }),
    };
};
const serializeAws_json1_0TimestreamConfiguration = (input, context) => {
    return {
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.DimensionMappings != null && {
            DimensionMappings: serializeAws_json1_0DimensionMappingList(input.DimensionMappings, context),
        }),
        ...(input.MeasureNameColumn != null && { MeasureNameColumn: input.MeasureNameColumn }),
        ...(input.MixedMeasureMappings != null && {
            MixedMeasureMappings: serializeAws_json1_0MixedMeasureMappingList(input.MixedMeasureMappings, context),
        }),
        ...(input.MultiMeasureMappings != null && {
            MultiMeasureMappings: serializeAws_json1_0MultiMeasureMappings(input.MultiMeasureMappings, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.TimeColumn != null && { TimeColumn: input.TimeColumn }),
    };
};
const serializeAws_json1_0UntagResourceRequest = (input, context) => {
    return {
        ...(input.ResourceARN != null && { ResourceARN: input.ResourceARN }),
        ...(input.TagKeys != null && { TagKeys: serializeAws_json1_0TagKeyList(input.TagKeys, context) }),
    };
};
const serializeAws_json1_0UpdateScheduledQueryRequest = (input, context) => {
    return {
        ...(input.ScheduledQueryArn != null && { ScheduledQueryArn: input.ScheduledQueryArn }),
        ...(input.State != null && { State: input.State }),
    };
};
const deserializeAws_json1_0AccessDeniedException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0CancelQueryResponse = (output, context) => {
    return {
        CancellationMessage: __expectString(output.CancellationMessage),
    };
};
const deserializeAws_json1_0ColumnInfo = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Type: output.Type != null ? deserializeAws_json1_0Type(output.Type, context) : undefined,
    };
};
const deserializeAws_json1_0ColumnInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0ColumnInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0ConflictException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0CreateScheduledQueryResponse = (output, context) => {
    return {
        Arn: __expectString(output.Arn),
    };
};
const deserializeAws_json1_0Datum = (output, context) => {
    return {
        ArrayValue: output.ArrayValue != null ? deserializeAws_json1_0DatumList(output.ArrayValue, context) : undefined,
        NullValue: __expectBoolean(output.NullValue),
        RowValue: output.RowValue != null ? deserializeAws_json1_0Row(output.RowValue, context) : undefined,
        ScalarValue: __expectString(output.ScalarValue),
        TimeSeriesValue: output.TimeSeriesValue != null
            ? deserializeAws_json1_0TimeSeriesDataPointList(output.TimeSeriesValue, context)
            : undefined,
    };
};
const deserializeAws_json1_0DatumList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0Datum(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0DescribeEndpointsResponse = (output, context) => {
    return {
        Endpoints: output.Endpoints != null ? deserializeAws_json1_0Endpoints(output.Endpoints, context) : undefined,
    };
};
const deserializeAws_json1_0DescribeScheduledQueryResponse = (output, context) => {
    return {
        ScheduledQuery: output.ScheduledQuery != null
            ? deserializeAws_json1_0ScheduledQueryDescription(output.ScheduledQuery, context)
            : undefined,
    };
};
const deserializeAws_json1_0DimensionMapping = (output, context) => {
    return {
        DimensionValueType: __expectString(output.DimensionValueType),
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_0DimensionMappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0DimensionMapping(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0Endpoint = (output, context) => {
    return {
        Address: __expectString(output.Address),
        CachePeriodInMinutes: __expectLong(output.CachePeriodInMinutes),
    };
};
const deserializeAws_json1_0Endpoints = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0Endpoint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0ErrorReportConfiguration = (output, context) => {
    return {
        S3Configuration: output.S3Configuration != null
            ? deserializeAws_json1_0S3Configuration(output.S3Configuration, context)
            : undefined,
    };
};
const deserializeAws_json1_0ErrorReportLocation = (output, context) => {
    return {
        S3ReportLocation: output.S3ReportLocation != null
            ? deserializeAws_json1_0S3ReportLocation(output.S3ReportLocation, context)
            : undefined,
    };
};
const deserializeAws_json1_0ExecutionStats = (output, context) => {
    return {
        BytesMetered: __expectLong(output.BytesMetered),
        DataWrites: __expectLong(output.DataWrites),
        ExecutionTimeInMillis: __expectLong(output.ExecutionTimeInMillis),
        QueryResultRows: __expectLong(output.QueryResultRows),
        RecordsIngested: __expectLong(output.RecordsIngested),
    };
};
const deserializeAws_json1_0InternalServerException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0InvalidEndpointException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0ListScheduledQueriesResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        ScheduledQueries: output.ScheduledQueries != null
            ? deserializeAws_json1_0ScheduledQueryList(output.ScheduledQueries, context)
            : undefined,
    };
};
const deserializeAws_json1_0ListTagsForResourceResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Tags: output.Tags != null ? deserializeAws_json1_0TagList(output.Tags, context) : undefined,
    };
};
const deserializeAws_json1_0MixedMeasureMapping = (output, context) => {
    return {
        MeasureName: __expectString(output.MeasureName),
        MeasureValueType: __expectString(output.MeasureValueType),
        MultiMeasureAttributeMappings: output.MultiMeasureAttributeMappings != null
            ? deserializeAws_json1_0MultiMeasureAttributeMappingList(output.MultiMeasureAttributeMappings, context)
            : undefined,
        SourceColumn: __expectString(output.SourceColumn),
        TargetMeasureName: __expectString(output.TargetMeasureName),
    };
};
const deserializeAws_json1_0MixedMeasureMappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0MixedMeasureMapping(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0MultiMeasureAttributeMapping = (output, context) => {
    return {
        MeasureValueType: __expectString(output.MeasureValueType),
        SourceColumn: __expectString(output.SourceColumn),
        TargetMultiMeasureAttributeName: __expectString(output.TargetMultiMeasureAttributeName),
    };
};
const deserializeAws_json1_0MultiMeasureAttributeMappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0MultiMeasureAttributeMapping(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0MultiMeasureMappings = (output, context) => {
    return {
        MultiMeasureAttributeMappings: output.MultiMeasureAttributeMappings != null
            ? deserializeAws_json1_0MultiMeasureAttributeMappingList(output.MultiMeasureAttributeMappings, context)
            : undefined,
        TargetMultiMeasureName: __expectString(output.TargetMultiMeasureName),
    };
};
const deserializeAws_json1_0NotificationConfiguration = (output, context) => {
    return {
        SnsConfiguration: output.SnsConfiguration != null
            ? deserializeAws_json1_0SnsConfiguration(output.SnsConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_0ParameterMapping = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Type: output.Type != null ? deserializeAws_json1_0Type(output.Type, context) : undefined,
    };
};
const deserializeAws_json1_0ParameterMappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0ParameterMapping(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0PrepareQueryResponse = (output, context) => {
    return {
        Columns: output.Columns != null ? deserializeAws_json1_0SelectColumnList(output.Columns, context) : undefined,
        Parameters: output.Parameters != null ? deserializeAws_json1_0ParameterMappingList(output.Parameters, context) : undefined,
        QueryString: __expectString(output.QueryString),
    };
};
const deserializeAws_json1_0QueryExecutionException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0QueryResponse = (output, context) => {
    return {
        ColumnInfo: output.ColumnInfo != null ? deserializeAws_json1_0ColumnInfoList(output.ColumnInfo, context) : undefined,
        NextToken: __expectString(output.NextToken),
        QueryId: __expectString(output.QueryId),
        QueryStatus: output.QueryStatus != null ? deserializeAws_json1_0QueryStatus(output.QueryStatus, context) : undefined,
        Rows: output.Rows != null ? deserializeAws_json1_0RowList(output.Rows, context) : undefined,
    };
};
const deserializeAws_json1_0QueryStatus = (output, context) => {
    return {
        CumulativeBytesMetered: __expectLong(output.CumulativeBytesMetered),
        CumulativeBytesScanned: __expectLong(output.CumulativeBytesScanned),
        ProgressPercentage: __limitedParseDouble(output.ProgressPercentage),
    };
};
const deserializeAws_json1_0ResourceNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        ScheduledQueryArn: __expectString(output.ScheduledQueryArn),
    };
};
const deserializeAws_json1_0Row = (output, context) => {
    return {
        Data: output.Data != null ? deserializeAws_json1_0DatumList(output.Data, context) : undefined,
    };
};
const deserializeAws_json1_0RowList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0Row(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0S3Configuration = (output, context) => {
    return {
        BucketName: __expectString(output.BucketName),
        EncryptionOption: __expectString(output.EncryptionOption),
        ObjectKeyPrefix: __expectString(output.ObjectKeyPrefix),
    };
};
const deserializeAws_json1_0S3ReportLocation = (output, context) => {
    return {
        BucketName: __expectString(output.BucketName),
        ObjectKey: __expectString(output.ObjectKey),
    };
};
const deserializeAws_json1_0ScheduleConfiguration = (output, context) => {
    return {
        ScheduleExpression: __expectString(output.ScheduleExpression),
    };
};
const deserializeAws_json1_0ScheduledQuery = (output, context) => {
    return {
        Arn: __expectString(output.Arn),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        ErrorReportConfiguration: output.ErrorReportConfiguration != null
            ? deserializeAws_json1_0ErrorReportConfiguration(output.ErrorReportConfiguration, context)
            : undefined,
        LastRunStatus: __expectString(output.LastRunStatus),
        Name: __expectString(output.Name),
        NextInvocationTime: output.NextInvocationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.NextInvocationTime)))
            : undefined,
        PreviousInvocationTime: output.PreviousInvocationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.PreviousInvocationTime)))
            : undefined,
        State: __expectString(output.State),
        TargetDestination: output.TargetDestination != null
            ? deserializeAws_json1_0TargetDestination(output.TargetDestination, context)
            : undefined,
    };
};
const deserializeAws_json1_0ScheduledQueryDescription = (output, context) => {
    return {
        Arn: __expectString(output.Arn),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        ErrorReportConfiguration: output.ErrorReportConfiguration != null
            ? deserializeAws_json1_0ErrorReportConfiguration(output.ErrorReportConfiguration, context)
            : undefined,
        KmsKeyId: __expectString(output.KmsKeyId),
        LastRunSummary: output.LastRunSummary != null
            ? deserializeAws_json1_0ScheduledQueryRunSummary(output.LastRunSummary, context)
            : undefined,
        Name: __expectString(output.Name),
        NextInvocationTime: output.NextInvocationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.NextInvocationTime)))
            : undefined,
        NotificationConfiguration: output.NotificationConfiguration != null
            ? deserializeAws_json1_0NotificationConfiguration(output.NotificationConfiguration, context)
            : undefined,
        PreviousInvocationTime: output.PreviousInvocationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.PreviousInvocationTime)))
            : undefined,
        QueryString: __expectString(output.QueryString),
        RecentlyFailedRuns: output.RecentlyFailedRuns != null
            ? deserializeAws_json1_0ScheduledQueryRunSummaryList(output.RecentlyFailedRuns, context)
            : undefined,
        ScheduleConfiguration: output.ScheduleConfiguration != null
            ? deserializeAws_json1_0ScheduleConfiguration(output.ScheduleConfiguration, context)
            : undefined,
        ScheduledQueryExecutionRoleArn: __expectString(output.ScheduledQueryExecutionRoleArn),
        State: __expectString(output.State),
        TargetConfiguration: output.TargetConfiguration != null
            ? deserializeAws_json1_0TargetConfiguration(output.TargetConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_0ScheduledQueryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0ScheduledQuery(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0ScheduledQueryRunSummary = (output, context) => {
    return {
        ErrorReportLocation: output.ErrorReportLocation != null
            ? deserializeAws_json1_0ErrorReportLocation(output.ErrorReportLocation, context)
            : undefined,
        ExecutionStats: output.ExecutionStats != null ? deserializeAws_json1_0ExecutionStats(output.ExecutionStats, context) : undefined,
        FailureReason: __expectString(output.FailureReason),
        InvocationTime: output.InvocationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.InvocationTime)))
            : undefined,
        RunStatus: __expectString(output.RunStatus),
        TriggerTime: output.TriggerTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.TriggerTime)))
            : undefined,
    };
};
const deserializeAws_json1_0ScheduledQueryRunSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0ScheduledQueryRunSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0SelectColumn = (output, context) => {
    return {
        Aliased: __expectBoolean(output.Aliased),
        DatabaseName: __expectString(output.DatabaseName),
        Name: __expectString(output.Name),
        TableName: __expectString(output.TableName),
        Type: output.Type != null ? deserializeAws_json1_0Type(output.Type, context) : undefined,
    };
};
const deserializeAws_json1_0SelectColumnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0SelectColumn(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0ServiceQuotaExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0SnsConfiguration = (output, context) => {
    return {
        TopicArn: __expectString(output.TopicArn),
    };
};
const deserializeAws_json1_0Tag = (output, context) => {
    return {
        Key: __expectString(output.Key),
        Value: __expectString(output.Value),
    };
};
const deserializeAws_json1_0TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0TagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_0TargetConfiguration = (output, context) => {
    return {
        TimestreamConfiguration: output.TimestreamConfiguration != null
            ? deserializeAws_json1_0TimestreamConfiguration(output.TimestreamConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_0TargetDestination = (output, context) => {
    return {
        TimestreamDestination: output.TimestreamDestination != null
            ? deserializeAws_json1_0TimestreamDestination(output.TimestreamDestination, context)
            : undefined,
    };
};
const deserializeAws_json1_0ThrottlingException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_0TimeSeriesDataPoint = (output, context) => {
    return {
        Time: __expectString(output.Time),
        Value: output.Value != null ? deserializeAws_json1_0Datum(output.Value, context) : undefined,
    };
};
const deserializeAws_json1_0TimeSeriesDataPointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_0TimeSeriesDataPoint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_0TimestreamConfiguration = (output, context) => {
    return {
        DatabaseName: __expectString(output.DatabaseName),
        DimensionMappings: output.DimensionMappings != null
            ? deserializeAws_json1_0DimensionMappingList(output.DimensionMappings, context)
            : undefined,
        MeasureNameColumn: __expectString(output.MeasureNameColumn),
        MixedMeasureMappings: output.MixedMeasureMappings != null
            ? deserializeAws_json1_0MixedMeasureMappingList(output.MixedMeasureMappings, context)
            : undefined,
        MultiMeasureMappings: output.MultiMeasureMappings != null
            ? deserializeAws_json1_0MultiMeasureMappings(output.MultiMeasureMappings, context)
            : undefined,
        TableName: __expectString(output.TableName),
        TimeColumn: __expectString(output.TimeColumn),
    };
};
const deserializeAws_json1_0TimestreamDestination = (output, context) => {
    return {
        DatabaseName: __expectString(output.DatabaseName),
        TableName: __expectString(output.TableName),
    };
};
const deserializeAws_json1_0Type = (output, context) => {
    return {
        ArrayColumnInfo: output.ArrayColumnInfo != null ? deserializeAws_json1_0ColumnInfo(output.ArrayColumnInfo, context) : undefined,
        RowColumnInfo: output.RowColumnInfo != null ? deserializeAws_json1_0ColumnInfoList(output.RowColumnInfo, context) : undefined,
        ScalarType: __expectString(output.ScalarType),
        TimeSeriesMeasureValueColumnInfo: output.TimeSeriesMeasureValueColumnInfo != null
            ? deserializeAws_json1_0ColumnInfo(output.TimeSeriesMeasureValueColumnInfo, context)
            : undefined,
    };
};
const deserializeAws_json1_0UntagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_0ValidationException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};

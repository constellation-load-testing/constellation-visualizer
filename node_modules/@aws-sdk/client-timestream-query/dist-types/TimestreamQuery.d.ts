import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
import { CancelQueryCommandInput, CancelQueryCommandOutput } from "./commands/CancelQueryCommand";
import { CreateScheduledQueryCommandInput, CreateScheduledQueryCommandOutput } from "./commands/CreateScheduledQueryCommand";
import { DeleteScheduledQueryCommandInput, DeleteScheduledQueryCommandOutput } from "./commands/DeleteScheduledQueryCommand";
import { DescribeEndpointsCommandInput, DescribeEndpointsCommandOutput } from "./commands/DescribeEndpointsCommand";
import { DescribeScheduledQueryCommandInput, DescribeScheduledQueryCommandOutput } from "./commands/DescribeScheduledQueryCommand";
import { ExecuteScheduledQueryCommandInput, ExecuteScheduledQueryCommandOutput } from "./commands/ExecuteScheduledQueryCommand";
import { ListScheduledQueriesCommandInput, ListScheduledQueriesCommandOutput } from "./commands/ListScheduledQueriesCommand";
import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "./commands/ListTagsForResourceCommand";
import { PrepareQueryCommandInput, PrepareQueryCommandOutput } from "./commands/PrepareQueryCommand";
import { QueryCommandInput, QueryCommandOutput } from "./commands/QueryCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "./commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "./commands/UntagResourceCommand";
import { UpdateScheduledQueryCommandInput, UpdateScheduledQueryCommandOutput } from "./commands/UpdateScheduledQueryCommand";
import { TimestreamQueryClient } from "./TimestreamQueryClient";
/**
 * <fullname>Amazon Timestream Query
 *         </fullname>
 *         <p></p>
 */
export declare class TimestreamQuery extends TimestreamQueryClient {
    /**
     * <p> Cancels a query that has been issued. Cancellation is provided only if the query has
     *             not completed running before the cancellation request was issued. Because cancellation
     *             is an idempotent operation, subsequent cancellation requests will return a
     *                 <code>CancellationMessage</code>, indicating that the query has already been
     *             canceled. See <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/code-samples.cancel-query.html">code
     *                 sample</a> for details. </p>
     */
    cancelQuery(args: CancelQueryCommandInput, options?: __HttpHandlerOptions): Promise<CancelQueryCommandOutput>;
    cancelQuery(args: CancelQueryCommandInput, cb: (err: any, data?: CancelQueryCommandOutput) => void): void;
    cancelQuery(args: CancelQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CancelQueryCommandOutput) => void): void;
    /**
     * <p> Create a scheduled query that will be run on your behalf at the configured schedule.
     *             Timestream assumes the execution role provided as part of the
     *                 <code>ScheduledQueryExecutionRoleArn</code> parameter to run the query. You can use
     *             the <code>NotificationConfiguration</code> parameter to configure notification for your
     *             scheduled query operations.</p>
     */
    createScheduledQuery(args: CreateScheduledQueryCommandInput, options?: __HttpHandlerOptions): Promise<CreateScheduledQueryCommandOutput>;
    createScheduledQuery(args: CreateScheduledQueryCommandInput, cb: (err: any, data?: CreateScheduledQueryCommandOutput) => void): void;
    createScheduledQuery(args: CreateScheduledQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateScheduledQueryCommandOutput) => void): void;
    /**
     * <p>Deletes a given scheduled query. This is an irreversible operation. </p>
     */
    deleteScheduledQuery(args: DeleteScheduledQueryCommandInput, options?: __HttpHandlerOptions): Promise<DeleteScheduledQueryCommandOutput>;
    deleteScheduledQuery(args: DeleteScheduledQueryCommandInput, cb: (err: any, data?: DeleteScheduledQueryCommandOutput) => void): void;
    deleteScheduledQuery(args: DeleteScheduledQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteScheduledQueryCommandOutput) => void): void;
    /**
     * <p>DescribeEndpoints returns a list of available endpoints to make Timestream
     *             API calls against. This API is available through both Write and Query.</p>
     *         <p>Because the Timestream SDKs are designed to transparently work with the
     *             serviceâ€™s architecture, including the management and mapping of the service endpoints,
     *                 <i>it is not recommended that you use this API unless</i>:</p>
     *         <ul>
     *             <li>
     *                 <p>You are using <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/VPCEndpoints">VPC endpoints (Amazon Web Services PrivateLink) with Timestream
     *                     </a>
     *                </p>
     *             </li>
     *             <li>
     *                 <p>Your application uses a programming language that does not yet have SDK
     *                     support</p>
     *             </li>
     *             <li>
     *                 <p>You require better control over the client-side implementation</p>
     *             </li>
     *          </ul>
     *         <p>For detailed information on how and when to use and implement DescribeEndpoints, see
     *                 <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/Using.API.html#Using-API.endpoint-discovery">The Endpoint Discovery Pattern</a>.</p>
     */
    describeEndpoints(args: DescribeEndpointsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEndpointsCommandOutput>;
    describeEndpoints(args: DescribeEndpointsCommandInput, cb: (err: any, data?: DescribeEndpointsCommandOutput) => void): void;
    describeEndpoints(args: DescribeEndpointsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEndpointsCommandOutput) => void): void;
    /**
     * <p>Provides detailed information about a scheduled query.</p>
     */
    describeScheduledQuery(args: DescribeScheduledQueryCommandInput, options?: __HttpHandlerOptions): Promise<DescribeScheduledQueryCommandOutput>;
    describeScheduledQuery(args: DescribeScheduledQueryCommandInput, cb: (err: any, data?: DescribeScheduledQueryCommandOutput) => void): void;
    describeScheduledQuery(args: DescribeScheduledQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeScheduledQueryCommandOutput) => void): void;
    /**
     * <p> You can use this API to run a scheduled query manually. </p>
     */
    executeScheduledQuery(args: ExecuteScheduledQueryCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteScheduledQueryCommandOutput>;
    executeScheduledQuery(args: ExecuteScheduledQueryCommandInput, cb: (err: any, data?: ExecuteScheduledQueryCommandOutput) => void): void;
    executeScheduledQuery(args: ExecuteScheduledQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteScheduledQueryCommandOutput) => void): void;
    /**
     * <p>Gets a list of all scheduled queries in the caller's Amazon account and Region. <code>ListScheduledQueries</code> is eventually consistent. </p>
     */
    listScheduledQueries(args: ListScheduledQueriesCommandInput, options?: __HttpHandlerOptions): Promise<ListScheduledQueriesCommandOutput>;
    listScheduledQueries(args: ListScheduledQueriesCommandInput, cb: (err: any, data?: ListScheduledQueriesCommandOutput) => void): void;
    listScheduledQueries(args: ListScheduledQueriesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListScheduledQueriesCommandOutput) => void): void;
    /**
     * <p>List all tags on a Timestream query resource.</p>
     */
    listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
    listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
    listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
    /**
     * <p>A synchronous operation that allows you to submit a query with parameters to be stored
     *             by Timestream for later running. Timestream only supports using this operation with the
     *                 <code>PrepareQueryRequest$ValidateOnly</code> set to <code>true</code>. </p>
     */
    prepareQuery(args: PrepareQueryCommandInput, options?: __HttpHandlerOptions): Promise<PrepareQueryCommandOutput>;
    prepareQuery(args: PrepareQueryCommandInput, cb: (err: any, data?: PrepareQueryCommandOutput) => void): void;
    prepareQuery(args: PrepareQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PrepareQueryCommandOutput) => void): void;
    /**
     * <p>
     *             <code>Query</code> is a synchronous operation that enables you to run a query against
     *             your Amazon Timestream data. <code>Query</code> will time out after 60 seconds.
     *             You must update the default timeout in the SDK to support a timeout of 60 seconds. See
     *             the <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/code-samples.run-query.html">code
     *                 sample</a> for details. </p>
     *         <p>Your query request will fail in the following cases:</p>
     *         <ul>
     *             <li>
     *                 <p> If you submit a <code>Query</code> request with the same client token outside
     *                     of the 5-minute idempotency window. </p>
     *             </li>
     *             <li>
     *                 <p> If you submit a <code>Query</code> request with the same client token, but
     *                     change other parameters, within the 5-minute idempotency window. </p>
     *             </li>
     *             <li>
     *                 <p> If the size of the row (including the query metadata) exceeds 1 MB, then the
     *                     query will fail with the following error message: </p>
     *                 <p>
     *                   <code>Query aborted as max page response size has been exceeded by the output
     *                         result row</code>
     *                 </p>
     *             </li>
     *             <li>
     *                 <p> If the IAM principal of the query initiator and the result reader are not the
     *                     same and/or the query initiator and the result reader do not have the same query
     *                     string in the query requests, the query will fail with an <code>Invalid
     *                         pagination token</code> error. </p>
     *             </li>
     *          </ul>
     */
    query(args: QueryCommandInput, options?: __HttpHandlerOptions): Promise<QueryCommandOutput>;
    query(args: QueryCommandInput, cb: (err: any, data?: QueryCommandOutput) => void): void;
    query(args: QueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: QueryCommandOutput) => void): void;
    /**
     * <p>Associate a set of tags with a Timestream resource. You can then activate these
     *             user-defined tags so that they appear on the Billing and Cost Management console for
     *             cost allocation tracking. </p>
     */
    tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
    tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
    tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
    /**
     * <p>Removes the association of tags from a Timestream query resource.</p>
     */
    untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
    untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
    untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
    /**
     * <p>Update a scheduled query.</p>
     */
    updateScheduledQuery(args: UpdateScheduledQueryCommandInput, options?: __HttpHandlerOptions): Promise<UpdateScheduledQueryCommandOutput>;
    updateScheduledQuery(args: UpdateScheduledQueryCommandInput, cb: (err: any, data?: UpdateScheduledQueryCommandOutput) => void): void;
    updateScheduledQuery(args: UpdateScheduledQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateScheduledQueryCommandOutput) => void): void;
}
